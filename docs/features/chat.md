# Chat System

This document describes the chat feature, including message handling, session management, streaming architecture, and Claude SDK integration.

## Overview

The chat system allows users to have conversations with Claude through configured agents. Key capabilities:
- **Streaming responses** - Real-time message updates via Server-Sent Events
- **Session persistence** - Conversations are saved and can be resumed
- **Tool execution** - Claude can use tools with permission prompts
- **Image attachments** - Send images for Claude to analyze (see [attachments.md](./attachments.md))
- **Agent integration** - Each session uses a configured agent (see [agents.md](./agents.md))

## Message Types

### Message Schema

Messages contain blocks of different types (text, thinking, tool calls):

```typescript
const MessageSchema = z.object({
    id: z.string(),
    role: z.enum(["user", "assistant"]),
    blocks: z.array(z.union([
        // Text content
        z.object({
            type: z.literal("text"),
            content: z.string(),
            id: z.string(),
        }),
        // Extended thinking
        z.object({
            type: z.literal("thinking"),
            content: z.string(),
            id: z.string(),
        }),
        // Tool calls
        z.object({
            type: z.literal("tool"),
            id: z.string(),
            toolCall: z.object({
                id: z.string(),
                name: z.string(),
                state: z.enum([
                    "input-streaming",
                    "input-available",
                    "output-available",
                    "output-error",
                ]),
                input: z.record(z.string(), z.any()).optional(),
                output: z.any().optional(),
                errorText: z.string().optional(),
            }),
        }),
        // Images (user messages only)
        z.object({
            type: z.literal("image"),
            content: z.string(),  // URL or base64
            id: z.string(),
        }),
    ])),
});

type ChatMessage = z.infer<typeof MessageSchema>;
```

### Content Block Types

| Type | Description | Role |
|------|-------------|------|
| `text` | Plain text content | user, assistant |
| `thinking` | Extended thinking (reasoning) | assistant |
| `tool` | Tool call with input/output | assistant |
| `image` | Image attachment | user |

### Tool Call States

| State | Description |
|-------|-------------|
| `input-streaming` | Tool input is being streamed |
| `input-available` | Tool input complete, awaiting execution |
| `output-available` | Tool executed successfully |
| `output-error` | Tool execution failed |

## Session Management

### Session Metadata

Each chat session has associated metadata:

```typescript
const SessionMetadataSchema = z.object({
    id: z.string(),                    // UUID generated by SDK
    title: z.string(),                 // Auto-generated or user-set
    createdAt: z.string(),             // ISO timestamp
    updatedAt: z.string(),             // ISO timestamp
    messageCount: z.number(),          // Total messages in session
    agentId: z.string().optional(),    // Agent used for this session
});

type SessionMetadata = z.infer<typeof SessionMetadataSchema>;
```

### Storage Locations

**Session Metadata:**
```
{workspace}/chat-sessions.jsonl
```

Each line is a JSON object with session metadata. New sessions are appended, updates replace matching IDs.

**Message History:**
```
~/.claude/projects/{workspace-path}/{sessionId}.jsonl
```

The Claude SDK manages message history in its own directory structure. The workspace path is converted (e.g., `/Users/foo/workspace` → `-Users-foo-workspace`).

### Session Lifecycle

1. **New Session**
   - User sends first message without `sessionId`
   - SDK generates UUID in `system/init` message
   - Frontend saves metadata via `/api/chat/sessions/save`
   - Title auto-generated from first user message

2. **Resume Session**
   - User opens existing session from browser
   - Frontend loads history via `/api/chat/sessions/history/{id}`
   - Messages reconstructed from SDK's JSONL file
   - New messages use `resume: sessionId` option

3. **Update Session**
   - Title can be edited via `/api/chat/sessions/update`
   - Message count updated after each exchange

## Streaming Architecture

### Request Flow

```
┌─────────────────┐
│  Chat View UI   │
│  (chat-view.tsx)│
└────────┬────────┘
         │ POST /api/chat
         │ { message, images, sessionId, agentId }
         ▼
┌─────────────────┐
│  Chat Routes    │
│  (chat-routes.ts)│
└────────┬────────┘
         │ Load agent config
         │ Build MCP servers
         ▼
┌─────────────────┐
│  Claude SDK     │
│  query()        │
└────────┬────────┘
         │ AsyncIterable<SDKMessage>
         ▼
┌─────────────────┐
│  SSE Stream     │◄─── Server-Sent Events
│  to Client      │
└─────────────────┘
```

### SSE Event Types

| Event | Data | Description |
|-------|------|-------------|
| `message` | `SDKMessage` | SDK message (system, assistant, user, result) |
| `permission_request` | `{ id, toolName, input }` | Tool needs approval |
| `done` | `{ sessionId }` | Query completed |
| `error` | `{ message }` | Query failed |
| `cancelled` | `{}` | Query was cancelled |

### SDK Message Types

The Claude SDK emits these message types:

```typescript
type SDKMessage =
    | { type: "system"; subtype: "init"; sessionId: string; mcpServers: [...] }
    | { type: "assistant"; content: ContentBlock[] }
    | { type: "user"; content: ContentBlock[] }  // Tool results
    | { type: "result"; ... };
```

### Message Reconstruction

When loading session history, SDK messages (JSONL) are converted to `ChatMessage[]`:

**File:** `src/features/chat/sessionUtils.ts`

```typescript
function reconstructMessages(sdkMessages: SDKMessage[]): ChatMessage[]
```

Conversion rules:
- `assistant` blocks → Text, thinking, tool call blocks
- `user` blocks with `tool_result` → Update tool state to output-available/error
- `user` blocks with text → Extract text content only
- Tool states progress: streaming → input-available → output-available

## Chat API

### Main Chat Endpoint

```
POST /api/chat
Content-Type: application/json

{
    "message": "Hello, Claude!",
    "images": ["/api/uploads/image.png"],  // Optional
    "sessionId": "uuid",                    // Optional (omit for new session)
    "agentId": "default"                    // Optional
}
```

Response: Server-Sent Events stream

### Permission Response

When a tool needs approval:

```
POST /api/chat/permission-response
Content-Type: application/json

{
    "permissionId": "uuid",
    "response": "allow" | "deny" | "always_allow"
}
```

### Cancel Query

```
POST /api/chat/cancel
Content-Type: application/json

{
    "queryTrackingId": "uuid"
}
```

### Session Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| POST | `/api/chat/sessions/save` | Save new session metadata |
| GET | `/api/chat/sessions/list` | List all sessions |
| GET | `/api/chat/sessions/history/{id}` | Load session messages |
| PUT | `/api/chat/sessions/update` | Update session title/count |
| POST | `/api/chat/sessions/delete` | Delete session metadata |
| POST | `/api/chat/sessions/search` | Search sessions by content |

## UI Components

### Chat View

**File:** `src/features/chat/chat-view.tsx`

Main chat interface component:

```tsx
<ChatView
    sessionId={sessionId}          // Optional: resume existing session
    tabId={tabId}                  // Tab identifier for state management
    initialPrompt={initialPrompt}  // Optional: pre-fill input
/>
```

Features:
- Message list with auto-scroll
- Streaming text/thinking display
- Tool call visualization (collapsible)
- Image attachments in messages
- Agent selector dropdown
- Cancel button during streaming
- Permission request banner

### Chat Browser

**File:** `src/features/chat/browser-view.tsx`

Session list/history browser:
- List all sessions with search
- Filter by title or content
- Show message preview snippet
- Delete sessions
- Open session in new tab

### Chat Input

**File:** `src/components/prosemirror/ProseMirrorPromptInput.tsx`

Rich text input with:
- Markdown formatting
- Image paste/drag-drop
- Attachment thumbnails
- Submit on Cmd+Enter

## Agent Integration

Each chat session uses an agent configuration that determines:
- **Model** - Which Claude model to use
- **System Prompt** - Custom instructions
- **MCP Servers** - Available tool integrations
- **Allowed Tools** - Pre-approved tool permissions

See [agents.md](./agents.md) for full agent documentation.

### Agent Selection Priority

1. `agentId` from request (explicit selection)
2. `agentId` from session metadata (existing session)
3. `lastUsedAgentId` from preferences (new session default)

### Agent Switching

Users can switch agents mid-conversation via the agent selector dropdown. The new agent applies to subsequent messages in that session.

## Tool Permission Flow

1. **SDK invokes canUseTool callback** with tool name and input
2. **Backend checks** if tool is in agent's `allowedTools`
3. **If pre-allowed**: Return `{ behavior: "allow" }` immediately
4. **If not allowed**:
   - Generate permission request ID
   - Send `permission_request` SSE event to client
   - Wait for response via `/api/chat/permission-response`
5. **User responds**:
   - **Deny**: Tool execution blocked
   - **Allow**: One-time permission granted
   - **Always Allow**: Permission persisted to agent config
6. **Stale cleanup**: Pending permissions expire after 5 minutes

## File Structure

```
src/
├── features/chat/
│   ├── index.ts              # Types, schemas, function stubs
│   ├── chat-view.tsx         # Main chat UI component
│   ├── browser-view.tsx      # Session browser component
│   ├── sessionUtils.ts       # Message reconstruction utilities
│   └── commands.tsx          # Command palette integration
├── server-routes/
│   └── chat-routes.ts        # Chat API endpoints
└── hooks/
    └── useChatAPI.ts         # Frontend API hook (if exists)
```

## Query Tracking

Active queries are tracked for cancellation support:

```typescript
// Map of queryTrackingId → AbortController
const activeQueries = new Map<string, AbortController>();
```

When a query starts:
1. Generate `queryTrackingId` UUID
2. Create `AbortController`
3. Store in `activeQueries` map
4. Pass `signal` to SDK query

When cancelled:
1. Look up controller by `queryTrackingId`
2. Call `controller.abort()`
3. SDK catches abort, stops streaming
4. Send `cancelled` SSE event

## Error Handling

### Query Errors

Errors during query execution are sent as SSE events:

```typescript
// SSE: event: error
data: { "message": "Error description" }
```

Frontend displays error toast and clears loading state.

### Tool Errors

Tool execution failures update the tool block state:

```typescript
{
    type: "tool",
    toolCall: {
        state: "output-error",
        errorText: "Tool execution failed: ..."
    }
}
```

### Session Errors

If session history file is missing or corrupted:
- Log warning
- Return empty message list
- Allow new messages (creates fresh history)
